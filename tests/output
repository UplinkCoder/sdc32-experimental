Reading 'tests.json' ... Done.
Runnig tests now.
would compile :
// Tests the simplest of programs.

int main() {
	return 42;
}


// Tests simple literal expressions.

int main() {
	return 42 + 21 * 2;
}


// Tests local variables with simple expressions.

int main() {
	int a = 42, b = 21;
	int c = 2;
	return a + b * c;
}


// Tests casting.

int main() {
	long a = 21; // int -> long, implicit
	int c = 21;
	if (a > c) {
		return 17;
	}
	
	return cast(int) a + c;
}


// Tests the casting of booleans to ints. 

int main() {
	bool a = false, b = true;
	if (cast(int) a != 0) {
		return 1;
	}
	
	if (cast(int) b != 1) {
		return 2;
	}
	
	a = true;
	return a + b + 10;
}

// Tests simple functions, and use before definition.

int main() {
	return add(21, add(19 + 1, 1));
}

int add(int a, int b) {
	return a + b;
}


// Create one variable of every primitive type.

int main() {
	bool b;
	byte by;
	ubyte uby;
	short s;
	ushort us;
	int i;
	uint ui;
	long l;
	ulong ul;
	float f;
	double d;
	real r;
	char c;
	wchar wc;
	dchar dc;
	
	return i;
}


// Tests increment on types smaller than int.

int main() {
	byte b;
	b++;
	
	return b;
}


// Tests increment/decrement semantics.

int add(int a, int b) {
	return a + b;
}

int main() {
	int a = 40;
	int b = 3;
	
	return add(a++, --b);
}


// Tests strings and character literals, and string/pointer casts.

extern(C) size_t strlen(const char* s);

int main() {
	string str = "test";  
	if(str.length != 4) {
		return 1;
	}
	
	if(str[2] != 's') {
		return 2;
	}
	
	auto p = str.ptr;
	if(strlen(p) != str.length) {
		return 3;
	}
	
	return 0;
}


// Tests typeof and evaluation of expressions with no side-effects.

int main() {
	int i = 12;
	typeof(i++) j;
	
	return i + j;
}


// Tests struct member functions, implicit and explicit this.

struct S {
	int c, d;
	
	int add(int a, int b) {
		return a + b + c + this.d;
	}
}

int main() {
	S s;
	s.c = s.d = 1;
	return s.add(38, 2);
}



int foo(int n) {
	if (n == 17) {
		return 16;
	} else if (n == 16) {
		return 32;
	} else {
		if (n == 0) {
			return 16;
		} else if (n == 17) {
			return 8;
		} else {
			return 7;
		}
	}
}

int main() {
	return foo(0) + 42;
}


// Simple type inference.

int main() {
	auto i = 42;
	return i;
}



int foo(int a) {
	if(a == 56 || a++) {
		a++;
	}
	
	if(a != 57 && a--) {
		a = 32;
	}
	
	if(a == 57 && a++) {}
	
	return a;
}

int main() {
	return foo(56);
}


// Simple test of ref.

void change(ref int i, int to) {
	i = to;
}

int main() {
	int i = 0;
	change(i, 73);
	return i;
}



int add(int a, int b) {
	return a + b;
}

int main() {
	int function(int, int) f;
	f = &add;
	return f(30, 2);
}



int main() {
	return 3++;
}



void foo(ref long i) {
	i = 42;
}

int main() {
	int i;
	foo(i);
	return i;
}



void foo(ref int i) {
	i = 42;
}

int main() {
	const int i = 21;
	foo(i);
	return i;
}


// Basic import testing

import test0020_import1;
import test0020_import2;

int main() {
	int a = importedFunction();
	int b = anotherImportedFunction();

	return a + b;
}


compiling dep:0
compiling dep:1

int foo() { return 42; }

int main() {
	int function()[] l;
	l.length = 1;
	l[0] = &foo;
	
	return l[0]();
}



import test0022_import1;

int begin() {
	return 1 + tenptr()() + addOne(&twelve) + 8;
}

int twelve() {
	return 12;
}

int main() {
	return start();
}


compiling dep:0

int foo() {
	return 42;
}

int main() {
	void* p = &foo;
	auto fn = (cast(int function())p)();
	
	return fn;
}



int main() {
	return (12);
}



int main() {
	return 12 - 2;
}



int main() {
	int i;
	void* p = &i;
	
	return *(cast(int*) p) + 2;
}



enum Foo {
	Bar,
	Baz,
}

int main() {
	return Foo.Baz;
}



enum {
	Bar,
	Baz,
}

int main() {
	return Baz;
}



enum A : byte {
	Foo,
}

enum B : long {
	Bar,
}

int main() {
	if(A.Foo.sizeof < B.Bar.sizeof) {
		return 42;
	} else {
		return 0;
	}
}



enum {
	A = 42,
	B = A,
}

int main() {
	return B;
}



struct S {
	enum O {
		B = 21,
	}
}

int main() {
	S s;
	return s.O.B + S.O.B;
}



int main() {
	auto a = new Object();
	auto b = new Object();
	
	return 1;
}



struct S {
	static int foo() {
		return 21;
	}

	int bar() {
		return 4;
	}
}

int main() {
	S s;
	
	return S.foo() + s.bar();
}



struct S {
	A foo(bar b) {
		A a;
		a.i = b;
		
		return a;
	}
}

struct A {
	int i;
}

alias bar = int;

int main() {
	S s;
	
	return s.foo(16).i + 1;
}



struct Foo {
	int i;
}

struct Bar {
	static Qux baz() {
		Foo f;
		f.i = 42;
		
		return f;
	}
	
	alias Qux = Foo;
}

int main() {
	return Bar.baz().i;
}


struct S {
	int i;
	int j;
	long k;
	int f() { return i + j; }
	alias f this;
	version (SDC) alias k this;  // DMD doesn't yet implement multiple alias this declarations.
}

int foo(int i){
	return i;
}

int main() {
	S s;
	s.i = 21;
	s.j = 21;
	
	return foo(s);
}


import test0037_import1;

alias Integer = int;
alias SS = test0037_import1.S;
alias bar = foo;
alias bas = bar;

int bazoooooooom() {
  return 2;
}

Integer main() {
  SS s;
  s.i = 30;
  bas(&s.i);

  return s;
}

compiling dep:0

int main() {
	int[] l = new int[1024];
	int a = 768;
	l[512] = 10;
	l[5]   = 1;
	l[a]   = 3;
	
	return l[512] + l[a] - l[7 - 2];
}



int main() {
	int i = 0;
	
FOO:
	i++;
	if(i != 42) {
		if(i == 27) {
			i = 27;
		}
		
		goto FOO;
	}
	
	return i;
}



auto add(int a, int b) {
	return a + b;
}

auto f() {
	return cast(ulong) 64;
}

int main() {
	ulong l = f();
	return add(20, 21);
}


import test0041_import1;

int main() {
	Foo foo;
	foo.bar();
	
	return 7;
}


compiling dep:0

import test0042_import1;

int main() {
	auto foo = new Foo();
	foo.dummy = 8;
	
	return foo.bar();
}


compiling dep:0

struct S
{



struct S {
	import object;
}

int main() {
	return 0;
}



struct A {
	int A;
	
	int foo() {
		return A;
	}
}

int main() {
	A a;
	
	return a.foo() + 7;
}



class Test {
	int i;
	
	this() {
		i = 12;
	}
	
	int foo() {
		return i + 1;
	}
}

int main() {
	auto test = new Test();
	return test.foo();
}



int add(int a, int b) {
	return a + b;
}

int add(int a, int b, int c) {
	return a + b + c;
}

int main() {
	return add(20, add(5, 2, 1));
}



void main() {}



int foo() {
	return 42;
}

int main() {
	return test0049.foo();
}



int add(int a, int b) { return a + b; }
int add(int a, int b, int c) { return a + b + c; }

int main() {
	int function(int, int) a = &add;
	return a(21, 21);
}



int add(int a, int b) { return a + b; }
int add(int a, int b, int c) { return a + b + c; }

int foo(int function(int, int) a) {
	return a(21, 21);
}

int main() {
	return foo(&add);
}



int main() {
	int i;
	i = 7;
	if (i == 7) {
		goto _out;
	}
	i++;
	_out:
	return i;
}



int main() {
	int i;
	i = 7;
	goto _out;
	_out:
	i++;
	return i;
}



static assert(false, "test 54 succeeded!");



void foo() {
	static assert(false, "test 55 succeeded!");
}



void main() {
	assert(false, "test 56 succeeded!");
}


#!/usr/bin/env rdmd
// Test the script at start of document

int main() {
	return 42;
}


// Name collision

import test0058_import1;
import test0058_import2;

int main() {
	int a = importedFunction();
	return a;
}


compiling dep:0
compiling dep:1
// Tests UTF-8 characters.

int åäö() { return 2; }
int aäo() { return 20; }
int åäo() { return 20; }

int main() {
	return åäö() + aäo() + åäo();
}


// Issue #25.

int func1() { return 2; }
int func2() { return 20; }
int func3() { return 20; }

int main() {
	return func1() + func2() func3();
}



int main() {
	string msg = "hello, world!";
	immutable char* cmsg = msg.ptr;
	assert(*cmsg == 'h');
	
	const char* cmsg2 = cmsg + 7;
	assert(*cmsg2 == 'w');
	assert(cmsg2 != cmsg);
	
	cmsg2++;
	assert(*cmsg2 == 'o');
	
	cmsg2 += 2;
	assert(*cmsg2 == 'l');
	
	cmsg2 -= 3;
	assert(*cmsg2 == 'w');
	
	cmsg2--;
	assert(*cmsg2 == ' ');
	
	assert(cmsg2 > cmsg);
	
	const(char)* cmsg3 = cmsg - 3;
	assert(cmsg3 < cmsg);
	
	cmsg3 = cmsg;
	assert(cmsg3 == cmsg);
	return 0;
}



int main() {
	string msg = "hello, world!";
	auto cmsg = msg.ptr;
	
	string hello = msg[0..5];
	assert(hello.length == 5);
	assert(hello[0] == 'h');
	assert(hello[4] == 'o');
	
	string world = cmsg[7..13];
	assert(world.length == 6);
	assert(world[0] == 'w');
	assert(world[5] == '!');
	
	return 0;
}



int main() {
	assert(0b0010 == 2);
	assert(0xF_F == 25_5);
	assert(0x0FL == 15L);
	return 0;
}



int main() {
	return 2 - 1 - 1;
}


//? desc:Test range foreach.

int main() {
	int i = 0;
	foreach(j; 1 .. 5) {
		i += j;
	}
	assert(i == 10);
	
	string str = "foobar";
	string str2 = "raboof";
	
	foreach(size_t j; 0 .. str.length) {
		assert(str[j] == str2[(str2.length - j) - 1]);
	}
	
	i = 0;
	foreach(char* it; str.ptr .. str.ptr + str.length) {
		assert(*it == str[i]);
		i++;
	}
	
	i = 0;
	foreach(ref j; 1 .. 10) {
		i += j;
		if(j == 5)
			j = 8;
	}
	assert(i == 24);
	
	// Break.
	i = 0;
	foreach(j; 0 .. 10) {
		if (j == 5)
			break;
		
		i++;
	}
	assert(i == 5);
	
	// Continue.
	i = 0;
	foreach(j; 0 .. 10) {
		if(j < 5)
			continue;
		
		i++;
	}
	assert(i == 5);
	return 0;
}


//? desc:Test aggregate foreach.

int main() {
	string str = "foobar";
	string str2 = "raboof";
	foreach(i, c; str) {
		assert(c == str2[(str2.length - i) - 1]);
	}
	
	int count;
	foreach(char c; str) {
		if (c == 'o')
			count++;
	}
	assert(count == 2);
	
	char* mem = cast(char*)malloc(str.length);
	foreach(size_t i, c; str) {
		mem[i] = c;
	}
	
	foreach(size_t i; 0..str.length) {
		assert(mem[i] == str[i]);
	}
	
	foreach(i, ref char c; mem[0..3]) {
		c = 'o';
	}
	
	foreach(i; 0..3) {
		assert(mem[i] == 'o');
	}
	
	char last;
	foreach(ref i, c; mem[0..1337]) {
		last = c;
		if (i == 5)
			i = 1337;
	}
	assert(last == 'r');
	
	// Break.
	foreach(ref c; mem[0..str.length]) {
		if(c == 'o')
			c = 'a';
		else
			break;
	}
	foreach(i; 0..3)
		assert(mem[i] == 'a');
	assert(mem[3] == 'b');
	
	// Continue.
	count = 0;
	foreach(c; str) {
		if (c != 'o')
			continue;
		
		count++;
	}
	assert(count == 2);
	return 0;
}



int main() {
	string str = "foobar";
	string str2 = "raboof";
	
	int count = 0;
	for(int i = 0; i < 10; i++)
		count++;
	
	assert(count == 10);
	
	ptrdiff_t i = str.length - 1;
	ptrdiff_t j = 0;
	for(; i > -1; i--) {
		assert(str[i] == str2[j]);
		j++;
	}
	
	// Break.
	i = 0;
	for(;;) {
		if(i == 10)
			break;
		else
			++i;
	}
	assert(i == 10);
	
	// Continue.
	i = 0;
	j = 0;
	for(i = 0; i < 10; i++) {
		if(i > 5)
			continue;
		++j;
	}
	assert(i == 10);
	assert(j == 6);
	return 0;
}


//? desc:Various cases for comments.

int main()
{
//      return 21;

// //   return 31;

        string a = /+ "+/" +/ 1";
        string c = /* "*/" */ 1";
        int    d = 1 + /* 2 */ + /+ 3 +/ // 4
                   + 5;
/*
        return 22;
*/

/*      return 23; */

/* /*   return 32; */

/+
        return 24;
+/

/+      return 25; +/

/+ /+   return 33; +/ +/

// /*   return 26; */
// /+   return 27; */

/* //   return 28; */
/* //   return 28; */

/*
     // return 29;
*/

/*
     /* return 34;
*/

/*
     /+ return 35;
*/

/+
     // return 30;   
+/

/+
     /* return 36;
+/

        return d;
}

//? desc:Disallow implicit conversion between function pointers of different calling convention.

extern(C) void foo(int a) {}

int main() {
	typeof(&foo) ok = &foo;
	void function(int) bad = &foo;
	return 0;
}

//? desc:Test the do-while loop.

int main() {
	int i = 0;
	do {
		i++;
	} while(i > 10); // Should run once.
	assert(i == 1);
	
	do i--;
	while(i > -10);
	assert(i == -10);
	
	// Break.
	i = 0;
	do {
		i++;
		if(i == 5)
			break;
	} while(i < 10);
	assert(i == 5);
	
	// Continue.
	i = 0;
	int j = 0;
	do {
		i++;
		if(i > 5)
			continue;
		j++;
	} while(i < 10);
	assert(j == 5);
	return 0;
}


//? desc:Test the while loop.

int main() {
	int i = 0;
	while(i < 10)
		i++;
	
	assert(i == 10);
	
	// Break.
	i = 0;
	while(i < 10) {
		i++;
		if(i == 5)
			break;
	}
	assert(i == 5);
	
	// Continue.
	i = 0;
	int j = 0;
	while(i < 10) {
		i++;
		if(i > 5)
			continue;
		j++;
	}
	assert(j == 5);
	return 0;
}



template Foo(T) {
	T bar;
}

int main() {
	Foo!int.bar = 4;
	return Foo!int.bar;
}



int main() {
	return 0;
}
/*/**/


//? desc:Test a basic switch.

int transmogrify(int input) {
	int output;
	switch (input) {
		default:
			output = 0;
			return output;
		case 1:
			output = 10;
			break;
		case 2:
			output = 20;
			break;
		case 3:
			output = 0;
			while(true) {
				++output;
				if (output == 30)
					break;
			}
			break;
	}
	return output;
}

int main() {
	bool didRun = false;
	switch(0) {
		didRun = true;
		default:
	}
	assert(!didRun);
	
	switch(0) { // Should not cause any warnings.
		case 0:
			didRun = true;
			break;
		default:
			break;
	}
	
	assert(didRun);
	
	assert(transmogrify(1) == 10);
	assert(transmogrify(2) == 20);
	assert(transmogrify(3) == 30);
	assert(transmogrify(4) == 0);
	return transmogrify(128);
}


//? desc:Test goto case multiple cases in case list.

int transmogrify(int input) {
	int output = 0;
	switch (input) {
		case 0, 1:
			if (input == 0)
				goto case;
			else
				output++;
			goto case;
		case 2:
			output += 5;
			goto case;
		case 3:
			output += 5;
			break;
		case 4, 5, 6:
			goto default;
		case 7:
		case 8:
			output += 20;
			break;
		default:
			return -1;
    }
	return output;
}

int main() {
	bool defaultRan = false;
	switch(0) {
		default:
			defaultRan = true;
			break;
		case 0:
			goto default;
	}
	assert(defaultRan);
	
	assert(transmogrify(0) == 10);
	assert(transmogrify(1) == 11);
	
	assert(transmogrify(2) == 10);
	assert(transmogrify(3) == 5);
	assert(transmogrify(7) == 20);
	assert(transmogrify(8) == 20);
	
	assert(transmogrify(4) == -1);
	assert(transmogrify(5) == -1);
	assert(transmogrify(6) == -1);
	assert(transmogrify(128) == -1);
	return 0;
}


//? desc:Test case range statements.

int transmogrify(int input) {
	switch(input) {
		case 0:
			return 1;
		case 1: .. case 10:
			return 2;
		case 11:
			return 3;
		case 12: .. case 12:
			return 4;
		case 13:
			return 5;
		default:
			return 0;
	}
}

void main() {
	assert(transmogrify(0) == 1);
	
	foreach(i; 1 .. 11)
		assert(transmogrify(i) == 2);
	
	assert(transmogrify(11) == 3);
	assert(transmogrify(12) == 4);
	assert(transmogrify(13) == 5);
	
	assert(transmogrify(14) == 0);
	assert(transmogrify(15) == 0);
}


void main() {
	string str = "foobar";

    // This is narrowing, but valid.
	foreach(byte i, c; str) {}
}



class Foo {
	void func1() {}
	
	void func2()
	body {}
	
	void func3()
	in {}
	body {}
	
	void func4()
	out {}
	body {}

	void func5()
	out {}
	in {}
	body {}
	
	void func6()
	in {}
	out {}
	body {}
}

void func1() {}

void func2()
body {}

void func3()
in {}
body {}

void func4()
out {}
body {}

void func5()
out {}
in {}
body {}

void func6()
in {}
out {}
body {}

int main() {
	return 4;
}



int main() {
	int a;
	auto b = &a;
	auto c = b;
	bool d = b == c;
	return 0;
}



alias bar = int;

int main() {
	return cast(int) ((int).sizeof + (bar).sizeof);
}



@property
int triple(int a) {
	return a * 3;
}

int foo() @property {
	return 2;
}

int main() {
	int a = 11;
	return a.triple + foo;
}



int main() {
	ubyte[123] arr;
	auto p = &arr[0];
	*p++ = cast(ubyte) 'A';
	return arr[0];
}




int main() {
	auto foobar = 0x80000000;
	return foobar.sizeof;
}



string s1 = "some string";

int main() {
	string s2 = "other string";
	return cast(int) ((s1 ~ s2).length);
}



int foobar = 42;

int main() {
	return foobar;
}



int main() {
	int a = 42;
	int b = 0;
	
	while(a > 0) {
		a--;
		b++;
	}
	
	return b;
}



int main() {
	int a = 42;
	int b = -14;
	
	while(a) {
		a--;
		
		if(a % 3) {
			b += 2;
		}
	}
	
	return b;
}



int main() {
	int a = 19;
	
	do {
		a--;
	} while(a > 20);
	
	return a;
}



int main() {
	int b;
	
	for(int a = 1; a < 10; a--) {
		a += 4;
		b = a;
	}
	
	return b;
}



int main() {
	for(int a = 1; a < 10; a++) {
		a++;
	}
	
	return a;
}



int main() {
	int a = 3;
	
	{
		int b = 5;
		
		b = a * b;
		a = b + a;
	}
	
	{
		int b;
		
		b = a + b;
		a = b + 24;
	}
	
	return a;
}



int main() {
	alias foo = int;
	
	return foo.sizeof;
}



struct S {
	int c, d;
}

int main() {
	S s;
	s.c = s.d = 1;
	
	int c = 40;
	
	return c + s.c + s.d;
}



template Foo(T) {
	T bar;
}

int main() {
	Foo!int.bar = 4;
	Foo!long.bar = 2 * Foo!int.bar;
	
	Foo!int.bar = 4 + cast(typeof(Foo!int.bar)) (Foo!long.bar + Foo!ulong.bar);
	
	return Foo!int.bar;
}



template Foo(T) {
	T Foo;
}

int main() {
	Foo!int = 4;
	Foo!long = 2 * Foo!int;
	
	Foo!int = 4 + cast(typeof(Foo!int)) (Foo!long + Foo!bool);
	
	return Foo!int;
}


// Tests implicit cast for function parameters.

int add(long a, ulong b) {
	return cast(int) (a + b);
}

int main() {
	int a = 25;
	int b = 2;
	
	return add(-12, add(add(a, b), add(b, a)));
}



alias Buzz = Fizz;

struct Bar {
	static auto baz() {
		Qux f;
		f.i = 42;
		return f;
	}
	
	alias Qux = Baz;
}

alias Baz = Foo;

struct Foo {
	Buzz i;
}

alias Fizz = int;

int main() {
	return Bar.baz().i;
}



int main() {
	return Foo!Bar.baz + Foo!Fizz.get7();
}

template Foo(T) {
	T Foo;
}

struct Fizz {
	Qux!Bar buzz;
	
	auto get7() {
		return buzz.baz + 2;
	}
}

struct Bar {
	Qux!int baz = 5;
}

template Qux(T) {
	alias Qux = T;
}



int main() {
	auto a = foo!bool() + foo!byte() + foo!ushort() + foo!int() + foo!float();
	assert(a == 10);
	
	a += foo!char();
	
	auto b = foo!long() + foo!double();
	
	assert(b == 30);
	
	return a + b;
}

uint foo(T)() {
	static if(buzz(T.sizeof)) {
		return 15;
	} else {
		return 2;
	}
}

bool buzz(size_t sizeof) {
	if(sizeof > 4) {
		return true;
	} else {
		return false;
	}
}



int main() {
	auto a = foo!bool() + foo!byte() + foo!ushort() + foo!int() + foo!float();
	assert(a == 40);
	
	a += foo!char();
	
	auto b = foo!long() + foo!double();
	assert(b == 512);
	
	return a + b;
}

uint foo(T)() {
	static if(buzz(T.sizeof) > 10) {
		uint ret = buzz(T.sizeof);
		return ret;
	} else {
		uint ret = T.sizeof / 2;
		return (ret + 1) * 2;
	}
}

uint buzz(size_t sizeof) {
	uint ret = 1;
	for(uint i = 0; i < sizeof; ++i) {
		ret *= 2;
	}
	
	return ret;
}



int main() {
	auto a = Foo!bool + Foo!byte + Foo!ushort + Foo!int + Foo!float;
	assert(a == 10);
	
	a += Foo!char;
	
	auto b = Foo!long + Foo!double;
	
	assert(b == 30);
	
	return a + b;
}

template Foo(T) {
	static if(buzz(T.sizeof)) {
		enum Foo = 15;
	} else {
		enum Foo = 2;
	}
}

bool buzz(size_t sizeof) {
	if(sizeof > 4) {
		return true;
	} else {
		return false;
	}
}



mixin("auto foo() { return 12; }");

int main() {
	return foo() + bar!uint(30);
}

string getStringMixin() {
	return "T bar(T)(T t) { mixin(\"return t;\"); }";
}

mixin(getStringMixin());


// Test creation of delegates from member function.

struct S {
	int i;
	T t;
	
	auto add(int a) {
		t.i = a + i;
		return t.add;
	}
}

struct T {
	int i;
	int add(int a) {
		return i + a;
	}
}

int main() {
	S s;
	s.i = s.t.i = 1;
	auto dg1 = s.add;
	auto dg2 = dg1(34);
	return dg2(7);
}


// Test creation of delegates from member function.

struct S {
	int i;
	T t;
	
	auto add(int a) {
		t.i = a + i;
		return t.add;
	}
}

struct T {
	int i;
	int add(int a) {
		return i + a;
	}
}

int main() {
	S s;
	s.i = s.t.i = 1;
	
	return s.add(34)(7);
}



int main() {
	return foo();
}

int foo() {
	return 3;
}

static if(foo() == 3) {
	int foo(int i) {
		return i;
	}
}



int main() {
	return 42;
}

string foo() {
	return "int foo(int i) { return i; }";
}

mixin(foo());



int main() {
	return foo(42);
}

string foo() {
	return bar();
}

mixin(bar());

string bar() {
	return "int foo(int i) { return i; }";
}



int foo(char* p) {
	if(*p == '\0') {
		return 0;
	}
	
	switch(*p) {
		case 'i' :
			p++;
			if(*p == '\0') {
				return 1;
			}
			
			switch(*p) {
				case 'f' :
					return 2;
				
				case 's' :
					return 3;
				
				default :
					return 42;
			}
		
		default :
			return 1;
	}
}

int main() {
	char[3] str;
	str[0] = 'i';
	str[1] = 'g';
	str[2] = '\0';
	
	return foo(&str[0]);
}


// Test recurence.

int main() {
	return fact(4) + fact(5) / fact(3) - fact(2);
}

int fact(int n) {
	if(n < 2) {
		return 1;
	}
	
	return n * fact(n - 1);
}


// Test function overloads.

int main() {
	byte b;
	short s;
	int i;
	long l;
	
	assert(foo(b) == 1);
	assert(foo(s) == 2);
	assert(foo(i) == 3);
	assert(foo(42) == 3);
	assert(foo(l) == 4);
	
	return 0;
}

int foo(byte b) {
	return 1;
}

int foo(short s) {
	return 2;
}

int foo(int i) {
	return 3;
}

int foo(long l) {
	return 4;
}


// Test exclusion of invalid ref overloads.

int main() {
	return foo(0);
}

int foo(ref int i) {
	return 3;
}

int foo(long l) {
	return 42;
}


// Test ref overloads.

int main() {
	int i = -1;
	return foo(i) + foo(30);
}

int foo(ref int i) {
	return i + 3;
}

int foo(int i) {
	return i + 10;
}


// Test ref overloads.

int main() {
	int i, j;
	return foo(i, j);
}

int foo(ref int i, int j) {
	return 0;
}

int foo(int i, ref int j) {
	return 0;
}


// Test overloads priority.

int main() {
	int i, j;
	return foo(i, j);
}

int foo(long i, long j) {
	return 23;
}

int foo(long i, int j) {
	return 17;
}


// Test virtual dispatch.

int main() {
	A a = new A();
	return a.foo();
}

class A {
	int foo() {
		return 42;
	}
}


// Test invalid override.

int main() {
	return 0;
}

class A {
	int foo() {
		return 3;
	}
}

class B : A {
	override long foo() {
		return 7;
	}
}


// Test invalid override.

int main() {
	return 0;
}

class A {
	void foo(int a) {}
}

class B : A {
	override void foo(long a) {}
}


// Test invalid override.

int main() {
	return 0;
}

class A {
	void foo(int a) {}
}

class B : A {
	override void bar(int a) {}
}


// Test implicit override error.

int main() {
	return 0;
}

class A {
	void foo(int a) {}
}

class B : A {
	void foo(int a) {}
}


// Test virtual dispatch.

int main() {
	A a = new B();
	return a.foo();
}

class A {
	int a = 15;
	
	int foo() {
		return a;
	}
}

class B : A {
	int b = 27;
	
	override int foo() {
		return a + b;
	}
}



int bar(int n) {
	switch(n) {
		case 0:
			return -9; // Bad case !
		
		case 25:
			return 75;
		
		case 42:
			return 69;
		
		case 666:
			return 999;
		
		default:
			return -1;
	}
}

int foo(int n) {
	if(n == 0) {
		return bar(n);	
	}
	
	switch(n) {
		case 1:
			return 23;
	
		case 2:
		case 3:
			return n;
		
		default:
			return bar(n);
	}
}

int main() {
	return foo(0) + foo(42) - foo(2);
}


// Test forward reference in enums.

enum Foo {
	Fizz,
	Pion,
	Bar = Baz + Pion,
	Baz = Buzz - Fizz,
	Qux = 40,
	Buzz,
}

int main() {
	return Foo.Bar;
}


// Test correct generation of temporary.

int main() {
	int[16] ii;
	int i = 12;
	
	ii[++i] = i;
	ii[i++] += i;
	
	(*(&ii[i--] - 1)) += 2;
	
	return ii[i] + i;
}


// Test template specialisation.

template Foo(T : T*) {
	enum Foo = T.sizeof;
}

int main() {
	return Foo!(char*) + Foo!(long*);
}


// Test template argument deduction.

template Foo(T : U[], U) {
	enum Foo = U.sizeof;
}

int main() {
	return Foo!(long[]) + Foo!string + Foo!(string[]);
}


// Test template overload on specialisation.

template Foo(T) {
	enum Foo = T.sizeof;
}

template Foo(T : T*) {
	enum Foo = T.sizeof;
}

template Foo(T : T[]) {
	enum Foo = T.sizeof;
}

int main() {
	return Foo!(int*) + Foo!(long[]) + Foo!char;
}


// Test invalid specialisation.

template Qux(T : U*, U : V*, V) {
	enum Qux = T.sizeof + V.sizeof;
}

int main() {
	return Qux!(float**, int*);
}


// Test IFTI with explicit and implicit parameter.

int foo()(int i) {
	return i + bar!int(13);
}

template Qux(T : U*, U) {
	uint Qux = T.sizeof + U.sizeof;
}

auto bar(T)(T t) {
	return t;
}

int main() {
	auto a = Qux!(float*);
	assert(a == 12);
	
	a += Qux!(int*, int);
	assert(a == 24);
	
	return foo(a) + bar(5);
}


// Test IFTI with explicit parameter and conversion.

int foo()(int i) {
	return i + cast(int) bar!long(i);
}

auto bar(T)(T t) {
	return T.sizeof + buzz(&t) + t;
}

auto buzz(T)(T* t) {
	return (*t)++;
}

auto qux(T : U*, U)(T t) {
	return buzz(t) + *t + U.sizeof;
}

int main() {
	int a = 5;
	
	return buzz(&a) + foo(a) + bar(1) + qux(&a);
}


// Test multiple argument IFTI.

auto foo(T, U)(T t, U u) {
	return t + T.sizeof + u + U.sizeof;
}

int main() {
	return foo('A', -28);
}


// Test IFTI with partial instanciation.

auto foo(T, U)(T t, U u) {
	return t + T.sizeof + u + U.sizeof;
}

int main() {
	return cast(int) foo!long('A', -35);
}


// Forbiden method name.

struct Foo {
	void __ctor() {}
}

void main() {}


// Forbiden method name.

struct Foo {
	void __dtor() {}
}

void main() {}


// Constructor.

struct Foo {
	int i;
	
	this(int i) {
		this.i = i;
	}
	
	auto bar() {
		return i;
	}
}

int main() {
	auto f = Foo(42);
	return f.bar();
}


// Method overload.

struct Foo {
	int i;
	
	this(int i) {
		this.i = i;
	}
	
	auto bar(int j) {
		return i + j;
	}
	
	int bar() {
		return bar(-5);
	}
}

int main() {
	auto f = Foo(47);
	return f.bar();
}


// Constructor forwarding.

struct Foo {
	int i;
	int j;
	
	this(int i) {
		this(i, 31);
	}
	
	this(int i, int j) {
		this.i = i;
		this.j = j;
	}
	
	auto bar() {
		return i + j;
	}
}

int main() {
	auto f = Foo(11);
	return f.bar();
}


// Newing structs.

struct Foo {
	int i;
	int j;
	
	this(int i, int j) {
		this.i = i;
		this.j = j;
	}
	
	auto bar(int k) {
		return i + j + k;
	}
}

int main() {
	auto f = new Foo(12, 35);
	return f.bar(-5);
}


// Constructor forwarding.

class Foo {
	int i;
	int j;
	
	this(int i) {
		this(i, 31);
	}
	
	this(int i, int j) {
		this.i = i;
		this.j = j;
	}
	
	auto bar() {
		return i + j;
	}
}

int main() {
	auto f = new Foo(11);
	return f.bar();
}


// Scope exit.

int a = 10;

int foo() {
	a++;
	scope(exit) a *= 2;
	
	return a++;
}

int main() {
	return foo() + a;
}


// Scope exit that returns.

int a = 10;

int foo() {
	scope(exit) a = 7;
	scope(exit) return a;
	
	return a++;
}

int main() {
	return foo() + a;
}


// Scope exit with nested blocks.

int a = 10;

int foo() {
	scope(exit) a = 11;
	
	{
		auto b = a;
		scope(exit) a = a * 3 + b;
		
		a = 7;
	}
	
	return a;
}

int main() {
	return foo() + a;
}


// Scope exit with conditional blocks.

int a = 9;

int foo(bool fi) {
	scope(exit) a = 11;
	
	auto b = a;
	if(fi) {
		a = 7;
		return a + b;
	}
	
	a = 5;
	return a + b;
}

int main() {
	return foo(true) + foo(false) + a;
}


// Scope exit with loops, break and continues.

int main() {
	uint a;
	for(int i = 0; i < 5; i++) {
		assert(a == i);
		
		scope(exit) a++;
		assert(a == i);
		
		a = i;
		assert(a == i);
	}
	
	assert(a == 5);
	
	while(true) {
		scope(exit) a = 23;
		break;
	}
	
	assert(a == 23);
	
	do {
		scope(exit) a--;
		
		if(a > 10) continue;
		break;
	} while(true);
	
	assert(a == 9);
	
	while(true) scope(exit) return 123;
}


// typeid.

class A {}
class B : A {}

void main() {
	Object a = new A();
	Object b = new B();
	
	assert(typeid(a) !is typeid(b));
	assert(typeid(typeof(a)) is typeid(typeof(b)));
	assert(typeid(a) !is typeid(typeof(b)));
	assert(typeid(typeof(a)) !is typeid(b));
	
	b = new A();
	
	assert(a !is b);
	assert(typeid(a) is typeid(b));
}


// downcast

class A {}
class B : A {}

void main() {
	Object a = new A();
	Object b = new B();
	
	auto a1 = cast(A) a;
	auto a2 = cast(B) a;
	
	assert(a1 is a);
	assert(a2 is null);
	
	auto b1 = cast(A) b;
	auto b2 = cast(B) b;
	
	assert(b1 is b);
	assert(b2 is b);
}


// bitwize operations

void main() {
	uint i = 1;
	
	assert((i << 2) == 4);
	assert((i >> 1) == 0);
	assert((i & 2) == 0);
	assert((i | 2) == 3);
	assert((i ^ 3) == 2);
}


// Throw

int main() {
	throw new Exception();
}


// Catch

int main() {
	try {
		throw new Exception();
	} catch(Error e) {
		return 23;
	} catch(Exception e) {
		return 19;
	} catch(Throwable e) {
		return 13;
	}
	
	return 42;
}


// Catch

auto a = 5;

void foo() {
	scope(exit) a++;
	throw new Exception();
}

int main() {
	try {
		foo();
	} catch(Exception e) {
		return a;
	}
	
	return 0;
}


// Catch

auto a = 7;

void foo() {
	try {
		throw new Exception();
	} catch(Exception e) {
		a += 2;
		throw new Exception();
	}
}

int main() {
	try {
		foo();
	} catch(Exception e) {
		return a;
	}
	
	return 0;
}


// Closure

int main() {
	int a = 10;
	int fooa() {
		return --a;
	}
	
	int b = 5;
	int foob() {
		return --a + b++;
	}
	
	return fooa() + foob() + a++ + b--;
}


// Closure

int main() {
	int a = 10;
	int foo() {
		return --a;
	}
	
	return () {
		return a++;
	}() + {
		return a -= 2;
	}() + foo() + ((int b) => a + b)(1);
}


// template value parameter

auto foo(T U, T)() {
	return U + T.sizeof;
}

int main() {
	return foo!true() + foo!10() + foo!I();
}

enum I = 5;


// Closure chaining

int main() {
	int a = 9;
	
	auto foo() {
		int b = 11;
		
		auto bar() {
			return a++ + b++;
		}
		
		return bar() + b;
	}
	
	return foo() + a;
}


// Closure chaining

int main() {
	int a = 11;
	
	auto foo() {
		int b = 25;
		
		auto bar() {
			return a + b;
		}
		
		return bar;
	}
	
	return foo()();
}


// template alias parameter (value)

auto foo(alias U)() {
	return U + typeof(U).sizeof;
}

int main() {
	return foo!true() + foo!10() + foo!I();
}

enum I = 5;


// alias of type and values

alias b = a;
alias c = 42;
alias d = c;
alias e = b;

b main() {
	a b = c;
	e f = b;
	return f;
}

alias a = uint;


//? desc:template typed alias parameter (value)

auto foo(alias T U, T)() {
	return U + T.sizeof;
}

int main() {
	return foo!true() + foo!10() + foo!I();
}

enum I = 5;


